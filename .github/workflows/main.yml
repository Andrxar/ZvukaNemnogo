name: TTS Batch Synthesis

on:
  workflow_dispatch:

permissions:
  contents: write
  actions: write

jobs:
  synthesize:
    runs-on: ubuntu-latest
    env:
      B2_KEY_ID: ${{ secrets.B2_KEY_ID }}
      B2_APP_KEY: ${{ secrets.B2_APP_KEY }}
      B2_BUCKET_ID: ${{ secrets.B2_BUCKET_ID }}
      B2_BUCKET_NAME: ${{ secrets.B2_BUCKET_NAME }}
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      GH_PAT: ${{ secrets.GH_PAT }}  # необязательный, на случай если GITHUB_TOKEN не позволяет dispatch
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Diagnose File State before script
        run: |
          echo "--- tail tts_batch.log BEFORE ---"
          [ -f tts_batch.log ] && tail -n 20 tts_batch.log || echo "no log yet"
          echo "-------------------------------"

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Install dependencies and tools
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt || true
          sudo apt-get update
          sudo apt-get install -y ffmpeg zip unzip jq

      - name: Run TTS batch script (single pass)
        run: |
          python -u tts_batch.py

      - name: Archive mp3 results (if present)
        if: always()
        run: |
          set -e
          if [ -d "output_mp3" ] && [ "$(ls -A output_mp3 2>/dev/null)" ]; then
            ZIPFILE="mp3_results_$(date +%Y%m%d%H%M%S).zip"
            zip -r "$ZIPFILE" output_mp3
            echo "Created $ZIPFILE"
            echo "::set-output name=zipfile::$ZIPFILE"
          else
            echo "No mp3 files to archive."
            echo "::set-output name=zipfile::"
          fi
        id: pack

      - name: Upload artifact (zip)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: mp3_results
          path: |
            mp3_results_*.zip

      - name: Upload created zips to Backblaze and verify, then delete GitHub artifact
        if: always()
        run: |
          set -euo pipefail
          # 1) Получаем список локальных zip-файлов (созданных сейчас)
          ZIP_LIST=(mp3_results_*.zip)
          exist=false
          for z in "${ZIP_LIST[@]}"; do
            if [ -f "$z" ]; then exist=true; break; fi
          done
          if [ "$exist" != true ]; then
            echo "No zip files to upload to Backblaze. Skipping upload step."
            exit 0
          fi

          echo "Authorizing with Backblaze B2..."
          AUTH_JSON=$(curl -s -u "${B2_KEY_ID}:${B2_APP_KEY}" https://api.backblazeb2.com/b2api/v2/b2_authorize_account)
          API_URL=$(echo "$AUTH_JSON" | jq -r .apiUrl)
          AUTH_TOKEN=$(echo "$AUTH_JSON" | jq -r .authorizationToken)
          if [ -z "$API_URL" ] || [ -z "$AUTH_TOKEN" ]; then
            echo "B2 auth failed: $AUTH_JSON"
            exit 1
          fi
          echo "Backblaze authorized (apiUrl discovered)."

          # Получаем upload URL (одно для загрузки файлов в бакет)
          UPLOAD_URL_JSON=$(curl -s -X POST "${API_URL}/b2api/v2/b2_get_upload_url" \
            -H "Authorization: ${AUTH_TOKEN}" \
            -d "{\"bucketId\":\"${B2_BUCKET_ID}\"}")
          UPLOAD_URL=$(echo "$UPLOAD_URL_JSON" | jq -r .uploadUrl)
          UPLOAD_AUTH_TOKEN=$(echo "$UPLOAD_URL_JSON" | jq -r .authorizationToken)
          if [ -z "$UPLOAD_URL" ] || [ -z "$UPLOAD_AUTH_TOKEN" ]; then
            echo "Failed to get upload url: $UPLOAD_URL_JSON"
            exit 1
          fi

          SUCCESS_ALL=true
          for z in "${ZIP_LIST[@]}"; do
            [ -f "$z" ] || continue
            echo "Uploading $z ..."
            FILE_NAME=$(basename "$z")
            # URL-encode filename:
            ENCODED_NAME=$(python3 - <<PY
import urllib.parse,sys
print(urllib.parse.quote(sys.argv[1], safe=''))
PY
"$FILE_NAME")
            UPLOAD_RESP=$(curl -s -X POST "$UPLOAD_URL" \
              -H "Authorization: ${UPLOAD_AUTH_TOKEN}" \
              -H "X-Bz-File-Name: ${ENCODED_NAME}" \
              -H "Content-Type: application/zip" \
              -H "X-Bz-Content-Sha1: do_not_verify" \
              --data-binary @"$z")
            echo "Upload response: $UPLOAD_RESP"
            fileId=$(echo "$UPLOAD_RESP" | jq -r .fileId // empty)
            if [ -z "$fileId" ]; then
              echo "Upload failed for $z"
              SUCCESS_ALL=false
              continue
            fi

            # Проверяем размер через b2_list_file_names
            LIST_RESP=$(curl -s -X POST "${API_URL}/b2api/v2/b2_list_file_names" \
              -H "Authorization: ${AUTH_TOKEN}" \
              -d "{\"bucketId\":\"${B2_BUCKET_ID}\",\"startFileName\":\"${FILE_NAME}\",\"maxFileCount\":100}")
            uploaded_size=$(echo "$LIST_RESP" | jq -r --arg FN "$FILE_NAME" '.files[] | select(.fileName == $FN) | .size' | head -n1)
            local_size=$(stat -c%s "$z")
            echo "Local size: $local_size, remote size: ${uploaded_size:-not-found}"
            if [ -z "$uploaded_size" ] || [ "$uploaded_size" -eq 0 ]; then
              echo "Remote size not found or zero for $FILE_NAME — marking as failure"
              SUCCESS_ALL=false
            else
              if [ "$local_size" -eq "$uploaded_size" ]; then
                echo "Upload verified by size for $FILE_NAME"
              else
                echo "Size mismatch for $FILE_NAME: local $local_size vs remote $uploaded_size"
                SUCCESS_ALL=false
              fi
            fi
          done

          if [ "$SUCCESS_ALL" = true ]; then
            echo "Все zip'ы успешно загружены в Backblaze. Удаляем GitHub artifact 'mp3_results'..."
            # Получаем список артефактов и удаляем артефакт с именем mp3_results
            ARTIFACTS_JSON=$(curl -s -H "Authorization: token ${GITHUB_TOKEN}" "https://api.github.com/repos/${{ github.repository }}/actions/artifacts")
            artifact_id=$(echo "$ARTIFACTS_JSON" | jq -r '.artifacts[] | select(.name=="mp3_results") | .id' | head -n1)
            if [ -n "$artifact_id" ]; then
              echo "Deleting artifact id: $artifact_id"
              curl -s -X DELETE -H "Authorization: token ${GITHUB_TOKEN}" "https://api.github.com/repos/${{ github.repository }}/actions/artifacts/${artifact_id}"
            else
              echo "Artifact mp3_results not found in repository artifacts list."
            fi
          else
            echo "Не все zip'ы были загружены успешно. GitHub artifact НЕ будет удалён."
          fi

      - name: Decide whether to dispatch another run (auto-continue)
        if: always()
        run: |
          set -e
          # 1) Compute total chunks using same splitting logic (max_length=980)
          python3 - <<'PY' > total_chunks.txt
import re,sys
fn = "Royzman_Delo-306-Volk-Vor-nevidimka.txt"
maxlen = 980
try:
    with open(fn, 'r', encoding='utf-8') as f:
        text = f.read()
except Exception:
    print(0); sys.exit(0)
delimiters = {'.','!','?'}
fragments = []
start = 0
L = len(text)
while start < L:
    end = start + maxlen
    if end >= L:
        fragments.append(text[start:])
        break
    while end > start and text[end-1] not in delimiters:
        end -= 1
    if end == start:
        end = start + maxlen
    fragments.append(text[start:end].strip())
    start = end
print(len(fragments))
PY
          total_chunks=$(cat total_chunks.txt | tr -d ' \n')
          echo "Total chunks according to splitter: $total_chunks"

          # 2) Get last processed index from tts_batch.log (pattern part_XXXX.mp3 with 'в пределах нормы' line)
          last_idx=0
          if [ -f tts_batch.log ]; then
            last_line=$(grep -oE "part_[0-9]{4}\.mp3" tts_batch.log | tail -n1 || true)
            if [ -n "$last_line" ]; then
              last_idx=$(echo "$last_line" | grep -oE "[0-9]{4}" | sed 's/^0*//')
              last_idx=${last_idx:-0}
            else
              last_idx=0
            fi
          fi
          echo "Last processed index (from log): $last_idx"

          # 3) If last_idx < total_chunks -> dispatch the same workflow again (auto-continue)
          if [ "$last_idx" -lt "$total_chunks" ]; then
            echo "Not finished yet (processed $last_idx of $total_chunks). Dispatching another run..."
            # Use GH_PAT if provided, otherwise GITHUB_TOKEN
            TOKEN="${GH_PAT}"
            if [ -z "$TOKEN" ]; then
              TOKEN="${GITHUB_TOKEN}"
            fi
            OWNER_REPO="${{ github.repository }}"
            WORKFLOW_FILE="tts_batch.yml"
            REF="main"
            curl -s -X POST \
              -H "Accept: application/vnd.github+json" \
              -H "Authorization: token ${TOKEN}" \
              "https://api.github.com/repos/${OWNER_REPO}/actions/workflows/${WORKFLOW_FILE}/dispatches" \
              -d "{\"ref\":\"${REF}\"}"
            echo "Dispatch request sent."
          else
            echo "All chunks processed (or no progress). No new run will be dispatched."
          fi

      - name: Commit and push log file & manifest
        if: always()
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          git pull --rebase || true
          git add -f tts_batch.log archives_manifest.json || true
          if ! git diff --staged --quiet; then
            git commit -m "Update tts_batch.log and archives_manifest"
            git push || true
          else
            echo "No changes to commit."
          fi
