name: TTS Batch Synthesis

on:
  workflow_dispatch:

jobs:
  synthesize:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: write
      packages: write

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Diagnose File State before script
        run: |
          echo "--- Checking if tts_batch.log exists BEFORE python script: ---"
          if [ -f "tts_batch.log" ]; then
            cat tts_batch.log | tail -n 5
          else
            echo "tts_batch.log does not exist yet."
          fi
          echo "--- End of initial diagnosis ---"

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install requests

      - name: Install ffmpeg
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg

      # --- Основной шаг: цикл запуска скрипта / архив / upload-to-B2 / delete-artifact ---
      - name: Run TTS loop with Backblaze upload
        env:
          BACKBLAZE_KEY_ID: ${{ secrets.BACKBLAZE_KEY_ID }}
          BACKBLAZE_APP_KEY: ${{ secrets.BACKBLAZE_APP_KEY }}
          BACKBLAZE_BUCKET_NAME: ${{ secrets.BACKBLAZE_BUCKET_NAME }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          set -o pipefail
          set -e

          # Если нужно больше вывода — раскомментируйте
          # set -x

          # вспомогательная функция - upload to Backblaze B2 (python snippet)
          upload_to_b2() {
            if [ ! -f "mp3_results.zip" ]; then
              echo "mp3_results.zip not found, skipping upload."
              return 1
            fi

            python - <<'PY'
import os, sys, json, requests

key = os.getenv("BACKBLAZE_KEY_ID")
app = os.getenv("BACKBLAZE_APP_KEY")
bucket_name = os.getenv("BACKBLAZE_BUCKET_NAME", "tts-artifacts")

if not key or not app:
    print("Backblaze credentials not provided.")
    sys.exit(2)

# 1) authorize
auth = requests.get("https://api.backblazeb2.com/b2api/v2/b2_authorize_account", auth=(key, app))
if auth.status_code != 200:
    print("B2 authorize failed:", auth.text)
    sys.exit(3)
authj = auth.json()
apiUrl = authj["apiUrl"]
authToken = authj["authorizationToken"]
accountId = authj["accountId"]

# 2) find or create bucket
r = requests.post(apiUrl + "/b2api/v2/b2_list_buckets", headers={"Authorization": authToken}, json={"accountId": accountId})
rj = r.json()
buckets = rj.get("buckets", [])
bucketId = None
for b in buckets:
    if b.get("bucketName") == bucket_name:
        bucketId = b.get("bucketId")
        break

if not bucketId:
    print("Bucket not found, creating bucket:", bucket_name)
    r = requests.post(apiUrl + "/b2api/v2/b2_create_bucket", headers={"Authorization": authToken}, json={"accountId": accountId, "bucketName": bucket_name, "bucketType": "allPrivate"})
    if r.status_code != 200:
        print("Failed create bucket:", r.text)
        sys.exit(4)
    bucketId = r.json()["bucketId"]

# 3) get upload url
r = requests.post(apiUrl + "/b2api/v2/b2_get_upload_url", headers={"Authorization": authToken}, json={"bucketId": bucketId})
if r.status_code != 200:
    print("Failed get_upload_url:", r.text)
    sys.exit(5)
upj = r.json()
uploadUrl = upj["uploadUrl"]
uploadAuth = upj["authorizationToken"]

# 4) upload file
fname = "mp3_results.zip"
with open(fname, "rb") as fh:
    data = fh.read()

headers = {
    "Authorization": uploadAuth,
    "X-Bz-File-Name": fname,
    "Content-Type": "application/zip",
    "X-Bz-Content-Sha1": "do_not_verify"
}
r = requests.post(uploadUrl, headers=headers, data=data)
if r.status_code != 200:
    print("Upload failed:", r.status_code, r.text)
    sys.exit(6)
upload_resp = r.json()
fileId = upload_resp.get("fileId")
if not fileId:
    print("No fileId in upload response:", upload_resp)
    sys.exit(7)

# 5) verify file by fetching file info
r = requests.post(apiUrl + "/b2api/v2/b2_get_file_info", headers={"Authorization": authToken}, json={"fileId": fileId})
if r.status_code != 200:
    print("b2_get_file_info failed:", r.text)
    sys.exit(8)
info = r.json()
remote_size = int(info.get("size", -1))
local_size = os.path.getsize(fname)
print("Local size:", local_size, "Remote size:", remote_size)
if local_size != remote_size:
    print("Size mismatch - upload corrupted.")
    sys.exit(9)

print("Upload to Backblaze succeeded and verified.")
sys.exit(0)
PY
            return $?
          }

          # основной цикл: запускаем tts_batch.py и реагируем на код 2 (limit reached)
          while true; do
            echo "Starting tts_batch.py..."
            python -u tts_batch.py || RC=$? && true
            RC=${RC:-0}
            echo "tts_batch.py returned code: $RC"
            if [ "$RC" -eq 2 ]; then
              echo "Limit reached -> creating zip and uploading to Backblaze..."
              if [ -d "output_mp3" ]; then
                rm -f mp3_results.zip
                zip -r mp3_results.zip output_mp3
              else
                echo "No output_mp3 folder found; nothing to zip."
              fi

              # загружаем на B2
              upload_to_b2
              UP_RC=$?
              if [ "$UP_RC" -ne 0 ]; then
                echo "Backblaze upload failed (code $UP_RC). Failing the job."
                exit $UP_RC
              fi

              # после успешной загрузки — удаляем ARTIFACTы на GitHub (если есть)
              echo "Searching for GitHub Actions artifact named 'mp3_results' to delete (if exists)..."
              repo="${GITHUB_REPOSITORY}"
              token="${GITHUB_TOKEN}"
              if [ -z "$token" ]; then
                echo "GITHUB_TOKEN not available; cannot delete artifacts automatically."
              else
                ART_LIST=$(curl -s -H "Authorization: token ${token}" "https://api.github.com/repos/${repo}/actions/artifacts")
                ART_ID=$(echo "$ART_LIST" | python -c "import sys, json
d=json.load(sys.stdin)
arts=d.get('artifacts',[])
for a in arts:
    if a.get('name')=='mp3_results':
        print(a.get('id'))
        break")
                if [ -n "$ART_ID" ]; then
                  echo "Deleting artifact id $ART_ID ..."
                  curl -s -X DELETE -H "Authorization: token ${token}" "https://api.github.com/repos/${repo}/actions/artifacts/${ART_ID}"
                  echo "Requested deletion of artifact $ART_ID."
                else
                  echo "No artifact named 'mp3_results' found."
                fi
              fi

              # очистка локальной zip (чтобы не перепутать в следующем цикле)
              rm -f mp3_results.zip

              # и продолжаем цикл — tts_batch.py будет запущен снова
              echo "Continuing loop to resume synthesis..."
              # очистим RC и повторим
              unset RC
              continue
            elif [ "$RC" -eq 0 ]; then
              echo "tts_batch.py finished normally (exit 0) — synthesis complete."
              break
            else
              echo "tts_batch.py exited with unexpected code $RC — aborting job."
              exit $RC
            fi
          done

      - name: Final artifact (optionally upload final results)
        if: always()
        run: |
          # В конце можно создать финальный архив и загрузить как артефакт Actions (если нужно)
          if [ -d "output_mp3" ]; then
            rm -f final_mp3_results.zip
            zip -r final_mp3_results.zip output_mp3
            echo "Final archive created: final_mp3_results.zip"
            # Если вы хотите, чтобы этот файл был доступен как артефакт Actions,
            # можно использовать actions/upload-artifact в отдельном шаге. (ниже — пример)
          else
            echo "No output_mp3 found at final step."
          fi

      - name: Upload final artifact to GitHub Actions (optional)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: final_mp3_results
          path: final_mp3_results.zip
